{% extends 'accounts/base.html' %}
{% load static %}

{% block title %}Планетарная система стартапов{% endblock %}

{% block head_extra %}
<link rel="stylesheet" href="{% static 'accounts/css/planetary_system.css' %}">
{% endblock %}

{% block content %}
  <div class="planetary-system-wrapper">
    <div class="planetary-system-container">
      <div class="space-background"></div>
      <div class="stars"></div>
      <div id="solar-system">
        <div id="scene">
          <div id="galaxy">
            <div id="logo" style="background-image: url('{{ logo_data.image }}');"></div>
            {% for planet in planets_data|slice:":10" %} <!-- Ограничиваем до 10 стартапов -->
              <div class="orbit" style="--orbit-size: {{ planet.orbit_size }}px; --orbit-time: {{ planet.orbit_time }}s;">
                <div class="planet-orientation">
                  <div class="planet" style="--planet-size: {{ planet.planet_size }}px; background-image: url('{{ planet.image }}');" data-id="{{ planet.id }}"></div>
                </div>
              </div>
            {% endfor %}
          </div>
        </div>
      </div>
      <div id="info-card">
        <button id="close-card">×</button>
        <div class="planet-image" id="planet-image"></div>
        <h2 id="startup-name"></h2>
        <div class="rating" id="startup-rating"></div>
        <div class="progress-bar">
          <button>Выкуп+инвестирование</button>
          <div class="progress" id="startup-progress"></div>
        </div>
        <div class="funding" id="startup-funding"></div>
        <div class="investors" id="startup-investors"></div>
        <div class="description" id="startup-description"></div>
        <button class="more-details" id="more-details">Подробнее</button>
      </div>
      <div id="crosshair"></div>
      <div id="crosshair-coords"></div>
      <div id="mouse-coords"></div>
      <div id="axes">
        <div class="axis" id="axis-x"></div>
        <div class="axis" id="axis-y"></div>
        <div class="axis" id="axis-z"></div>
        <div class="axis-label" id="label-x">X</div>
        <div class="axis-label" id="label-y">Y</div>
        <div class="axis-label" id="label-z">Z</div>
      </div>
      <div id="fps">0 FPS</div>
      <div id="galaxy-selector">
        <div id="galaxy-list">
          {% for direction in directions %}
            <div class="galaxy-item {% if direction.direction_name == selected_galaxy %}selected{% endif %}" data-name="{{ direction.direction_name }}">{{ direction.direction_name }}</div>
          {% endfor %}
        </div>
      </div>
    </div>
  </div>
{% endblock %}

{% block body_scripts %}
  <script>
    const startups = {
      {% for planet in planets_data|slice:":10" %} <!-- Ограничиваем до 10 стартапов -->
        '{{ planet.id }}': {
          name: '{{ planet.name }}',
          description: '{{ planet.description }}',
          rating: '{{ planet.rating }}',
          progress: '{{ planet.progress }}',
          funding: '{{ planet.funding }}',
          investors: '{{ planet.investors }}',
          image: '{{ planet.image }}',
          startup_id: '{{ planet.startup_id }}'
        }{% if not forloop.last %},{% endif %}
      {% endfor %}
    };

    const planets = document.querySelectorAll('.planet');
    const infoCard = document.getElementById('info-card');
    const planetImage = document.getElementById('planet-image');
    const startupName = document.getElementById('startup-name');
    const startupRating = document.getElementById('startup-rating');
    const startupProgress = document.getElementById('startup-progress');
    const startupFunding = document.getElementById('startup-funding');
    const startupInvestors = document.getElementById('startup-investors');
    const startupDescription = document.getElementById('startup-description');
    const closeCard = document.getElementById('close-card');
    const moreDetails = document.getElementById('more-details');
    const solarSystem = document.getElementById('solar-system');
    const scene = document.getElementById('scene');
    const galaxy = document.getElementById('galaxy');
    const crosshairCoords = document.getElementById('crosshair-coords');
    const mouseCoords = document.getElementById('mouse-coords');
    const fpsElement = document.getElementById('fps');
    const galaxySelector = document.getElementById('galaxy-selector');
    const galaxyList = document.getElementById('galaxy-list');

    // Переменная для хранения текущего выбранного стартапа
    let currentStartupId = null;

    // Начальный угол наклона галактики
    const galaxyTiltAngle = 45;

    // Для расчета FPS
    let lastTime = 0;
    let frameCount = 0;
    let fps = 0;

    // Переменные для управления паузой
    let isPaused = false;
    let pausedTime = 0;

    // Переменные для возвращения к центру
    let lastInteractionTime = Date.now();
    const inactivityTimeout = 10000;
    let isReturningToCenter = false;

    // Переменные для перемещения и масштабирования
    let isDragging = false;
    let startX, startY;
    let offsetX = 0;
    let offsetY = 0;
    let scale = 1;

    planets.forEach(planet => {
      const randomAngle = Math.random() * 360;
      planet.parentElement.parentElement.style.setProperty('--random-angle', `${randomAngle}deg`);

      const randomSpeedFactor = 0.8 + Math.random() * 0.4;
      planet.parentElement.parentElement.style.setProperty('--random-speed-factor', randomSpeedFactor);

      const id = planet.getAttribute('data-id');
      planet.style.backgroundImage = `url('${startups[id].image}')`;
      planet.addEventListener('click', (e) => {
        e.stopPropagation();
        const startup = startups[id];

        planetImage.style.backgroundImage = `url('${startup.image}')`;
        startupName.textContent = startup.name;
        startupRating.textContent = `Рейтинг ${startup.rating}`;
        startupProgress.textContent = startup.progress;
        startupFunding.textContent = `Цель финансирования: ${startup.funding}`;
        startupInvestors.textContent = startup.investors;
        startupDescription.textContent = startup.description;

        // Сохраняем startup_id текущего стартапа
        currentStartupId = startup.startup_id;

        planets.forEach(p => p.classList.remove('active'));
        planet.classList.add('active');
        infoCard.style.display = 'block';

        // Приостановить вращение планет
        isPaused = true;
        pausedTime = Date.now();

        // Обновляем время последнего взаимодействия
        lastInteractionTime = Date.now();
      });
    });

    closeCard.addEventListener('click', () => {
      infoCard.style.display = 'none';
      planets.forEach(p => p.classList.remove('active'));

      // Возобновить вращение планет с того же места
      if (isPaused) {
        const pauseDuration = Date.now() - pausedTime;
        planetObjects.forEach(planetObj => {
          planetObj.startTime += pauseDuration;
        });
        isPaused = false;
      }

      // Обновляем время последнего взаимодействия
      lastInteractionTime = Date.now();
    });

    moreDetails.addEventListener('click', () => {
      // Проверяем, есть ли текущий startup_id
      if (currentStartupId) {
        // Перенаправляем пользователя на страницу стартапа
        window.location.href = `/startups/${currentStartupId}/`;
      } else {
        console.error('Startup ID не найден для перехода на страницу стартапа');
      }

      // Скрываем карточку
      infoCard.style.display = 'none';
      planets.forEach(p => p.classList.remove('active'));

      // Возобновить вращение планет с того же места
      if (isPaused) {
        const pauseDuration = Date.now() - pausedTime;
        planetObjects.forEach(planetObj => {
          planetObj.startTime += pauseDuration;
        });
        isPaused = false;
      }

      // Обновляем время последнего взаимодействия
      lastInteractionTime = Date.now();
    });

    solarSystem.addEventListener('mousedown', (e) => {
      e.preventDefault();
      const rect = solarSystem.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      isDragging = true;
      solarSystem.classList.add('dragging');

      lastInteractionTime = Date.now();
      isReturningToCenter = false;
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const rect = solarSystem.getBoundingClientRect();
      const deltaX = e.clientX - rect.left - startX;
      const deltaY = e.clientY - rect.top - startY;

      offsetX += deltaX;
      offsetY += deltaY;

      // Ограничиваем перемещение внутри контейнера
      const maxX = (rect.width / 2) / scale;
      const maxY = (rect.height / 2) / scale;
      offsetX = Math.max(-maxX, Math.min(maxX, offsetX));
      offsetY = Math.max(-maxY, Math.min(maxY, offsetY));

      scene.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;

      crosshairCoords.textContent = `Center: (${Math.round(offsetX)}, ${Math.round(offsetY)}, 0)`;

      mouseCoords.style.left = `${Math.min(rect.width - 80, Math.max(0, e.clientX - rect.left))}px`;
      mouseCoords.style.top = `${Math.min(rect.height - 30, Math.max(0, e.clientY - rect.top))}px`;
      mouseCoords.textContent = `Mouse: (${Math.round(e.clientX - rect.left)}, ${Math.round(e.clientY - rect.top)})`;

      lastInteractionTime = Date.now();
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      solarSystem.classList.remove('dragging');
      lastInteractionTime = Date.now();
    });

    solarSystem.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = solarSystem.getBoundingClientRect();
      const delta = e.deltaY > 0 ? -0.1 : 0.1;
      scale = Math.max(0.5, Math.min(3, scale + delta));
      scene.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px) scale(${scale})`;

      crosshairCoords.textContent = `Center: (${Math.round(offsetX)}, ${Math.round(offsetY)}, 0)`;

      mouseCoords.style.left = `${Math.min(rect.width - 80, Math.max(0, e.clientX - rect.left))}px`;
      mouseCoords.style.top = `${Math.min(rect.height - 30, Math.max(0, e.clientY - rect.top))}px`;
      mouseCoords.textContent = `Mouse: (${Math.round(e.clientX - rect.left)}, ${Math.round(e.clientY - rect.top)})`;

      lastInteractionTime = Date.now();
      isReturningToCenter = false;
    });

    infoCard.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      lastInteractionTime = Date.now();
    });

    document.addEventListener('mousemove', (e) => {
      const rect = solarSystem.getBoundingClientRect();
      mouseCoords.style.left = `${Math.min(rect.width - 80, Math.max(0, e.clientX - rect.left))}px`;
      mouseCoords.style.top = `${Math.min(rect.height - 30, Math.max(0, e.clientY - rect.top))}px`;
      mouseCoords.textContent = `Mouse: (${Math.round(e.clientX - rect.left)}, ${Math.round(e.clientY - rect.top)})`;
    });

    function checkInactivity() {
      const now = Date.now();
      if (now - lastInteractionTime >= inactivityTimeout && !isReturningToCenter && !isPaused) {
        isReturningToCenter = true;
        const startX = offsetX;
        const startY = offsetY;
        const duration = 1000;
        let startTime = null;

        function animateReturn(timestamp) {
          if (!startTime) startTime = timestamp;
          const elapsed = timestamp - startTime;
          const progress = Math.min(elapsed / duration, 1);

          offsetX = startX + (0 - startX) * progress;
          offsetY = startY + (0 - startY) * progress;

          scene.style.transform = `translate(-50%, -50%) translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
          crosshairCoords.textContent = `Center: (${Math.round(offsetX)}, ${Math.round(offsetY)}, 0)`;

          if (progress < 1) {
            requestAnimationFrame(animateReturn);
          } else {
            isReturningToCenter = false;
          }
        }

        requestAnimationFrame(animateReturn);
      }
    }

    setInterval(checkInactivity, 1000);

    function updatePlanets() {
      const now = Date.now();
      
      frameCount++;
      if (now - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = now;
        fpsElement.textContent = `${fps} FPS`;
      }

      if (isPaused) {
        requestAnimationFrame(updatePlanets);
        return;
      }

      planetObjects.forEach(planetObj => {
        const elapsedSeconds = (now - planetObj.startTime) / 1000;
        const orbitTimeSeconds = planetObj.orbitTime * planetObj.speedFactor;
        const progress = (elapsedSeconds % orbitTimeSeconds) / orbitTimeSeconds;
        const angle = planetObj.angle + progress * 360;
        const angleRad = angle * Math.PI / 180;
        
        const radius = planetObj.orbitSize / 2;
        const x = Math.cos(angleRad) * radius;
        const y = Math.sin(angleRad) * radius;
        
        planetObj.orientation.style.left = `${50 + 50 * (x / radius)}%`;
        planetObj.orientation.style.top = `${50 + 50 * (y / radius)}%`;

        const tiltCompensation = -galaxyTiltAngle;
        planetObj.element.style.transform = `rotateX(${tiltCompensation}deg)`;
      });
      
      requestAnimationFrame(updatePlanets);
    }

    const planetObjects = [];
    planets.forEach((planet, index) => {
      const orbit = planet.closest('.orbit');
      const planetOrientation = planet.closest('.planet-orientation');
      
      const orbitSize = parseFloat(getComputedStyle(orbit).getPropertyValue('--orbit-size'));
      const orbitTime = parseFloat(getComputedStyle(orbit).getPropertyValue('--orbit-time'));
      
      const initialAngle = Math.random() * 360;
      const speedFactor = 0.8 + Math.random() * 0.4;
      
      planetObjects.push({
        element: planet,
        orientation: planetOrientation,
        orbit: orbit,
        size: parseFloat(getComputedStyle(planet).getPropertyValue('--planet-size')),
        orbitSize: orbitSize,
        orbitTime: orbitTime,
        angle: initialAngle,
        speedFactor: speedFactor,
        startTime: Date.now() - Math.random() * orbitTime * 1000
      });
    });

    let scrollVelocity = 0;
    let lastScrollTime = 0;

    galaxySelector.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY * 10;
      scrollVelocity += delta;
      lastScrollTime = Date.now();

      lastInteractionTime = Date.now();
    });

    function smoothScroll() {
      const now = Date.now();
      const timeSinceLastScroll = now - lastScrollTime;

      if (timeSinceLastScroll < 100) {
        galaxySelector.scrollLeft += scrollVelocity;
        scrollVelocity *= 0.95;
      } else {
        scrollVelocity = 0;
      }

      const containerRect = galaxySelector.getBoundingClientRect();
      const containerCenter = containerRect.left + containerRect.width / 2;
      const items = document.querySelectorAll('.galaxy-item');

      items.forEach(item => {
        const itemRect = item.getBoundingClientRect();
        const itemCenter = itemRect.left + itemRect.width / 2;
        const distanceFromCenter = Math.abs(containerCenter - itemCenter);
        const maxDistance = containerRect.width / 2;

        const scale = Math.max(0.5, 1 - (distanceFromCenter / maxDistance));
        const fontSize = 16 * scale;
        item.style.transform = `scale(${scale})`;
        item.style.fontSize = `${fontSize}px`;
      });

      requestAnimationFrame(smoothScroll);
    }

    requestAnimationFrame(smoothScroll);

    document.querySelectorAll('.galaxy-item').forEach(item => {
      item.addEventListener('click', () => {
        const galaxyName = item.getAttribute('data-name');
        window.location.href = `{% url 'planetary_system' %}?galaxy=${encodeURIComponent(galaxyName)}`;
      });
    });

    requestAnimationFrame(updatePlanets);

    crosshairCoords.textContent = `Center: (${Math.round(offsetX)}, ${Math.round(offsetY)}, 0)`;
  </script>
{% endblock %}